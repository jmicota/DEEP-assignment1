# -*- coding: utf-8 -*-
"""Kopia notatnika DEEP-Assignment1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IgREBgDBRge75_oPxDtkdKhdhLa3PIdd

A stock-movement prediction model for the company  *UpUpUp Inc*. 

Authors:

*   Eva Ósk Gunnarsdóttir (evag18@ru.is)
*   Justyna Micota (justyna22@ru.is)
"""

# Set flexable variables to play with
BATCH_SIZE = 10
NN_WIDTH = 32
LR = 0.001
N_EPOCHS = 10

"""# Fetch data and provided functions

Here we fetch the given functions and data (stock pricees, market analysis, market segments and info)
"""

# Import necessary libraries
import torch
import torch.nn as nn
import pandas as pd
# from google.colab import drive
# from os.path import join

# ROOT = '/content/drive'
# drive.mount(ROOT, force_remount=True)
#
# PROJ = 'MyDrive/DEEP-Assignment1'
# PROJ_PATH = join(ROOT, PROJ)
# !rsync -aP "{PROJ_PATH}"/* ./

import simulator
import stock_preprocessing as spp
import model

"""# Preprocess/ prepare data

Here we join the information of the given data (stock pricees, market analysis, market segments and info) to a single table.

Stock_preprocessing module contains process_training_data method, that standardizes data, and generates train and test Dataloaders for training purposes.
"""

stock_prices = []
market_analysis = []
market_segments = []
info = []

simulator.read_stock_prices(stock_prices)
simulator.read_market_analysis(market_analysis)
simulator.read_market_segments(market_segments)
simulator.read_info(info)

train_dl, test_dl = spp.create_training_dataloaders(market_segments, market_analysis, info, stock_prices, BATCH_SIZE)
input_layer_size = len(train_dl.dataset[0][0]) * len(train_dl.dataset[0][0][0])

"""# Build the Neural Network Model"""

stock_market_predictor_0000 = model.StocksModel(input_layer_size)
print(stock_market_predictor_0000)

"""# Train Model"""

optimizer = torch.optim.Adam(stock_market_predictor_0000.parameters(), lr=LR)

for epochs in range(N_EPOCHS):
    for data in train_dl:
        X, y = data
        optimizer.zero_grad()  # clear gradient information.
        output = stock_market_predictor_0000(X.view(-1, len(X[0]) * len(X[0][0])))
        loss = nn.functional.nll_loss(output, y)
        loss.backward()  # do pack-propagation step
        optimizer.step()  # update weights

"""# Evaluate"""

total = 0
correct = 0
with torch.no_grad():  # No need for keepnig track of necessary changes to the gradient.
    for data in test_dl:
        X, y = data
        output = stock_market_predictor_0000(X.view(-1, len(X[0]) * len(X[0][0])))
        for idx, val in enumerate(output):
            if torch.argmax(val) == y[idx]:
                correct += 1
            total += 1
    print('Accuracy:', round(correct / total, 3))

"""# Check Predictor compatibility"""

import predictor

predictor_object = predictor.Predictor('stocks_predictor', stock_market_predictor_0000)
simulator.simulate(2017, 1, predictor_object)

# predictor_object.predict(market_segments, market_analysis, info, [1,1,1,1])
